(()=>{"use strict";var t={d:(e,r)=>{for(var o in r)t.o(r,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:r[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{HexMemoryMap:()=>i,S19MemoryMap:()=>f});const r=/:([0-9A-Fa-f]{8,})([0-9A-Fa-f]{2})(?:\r\n|\r|\n|)/g;function o(t){return 255&-t.reduce((t,e)=>t+e,0)}function n(t,e){return 255&-(t.reduce((t,e)=>t+e,0)+e.reduce((t,e)=>t+e,0))}function s(t){return t.toString(16).toUpperCase().padStart(2,"0")}function a(t,e=10){return parseInt(t,e)>>>0&4294967295}Number.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t};class i{_blocks;constructor(t){if(this._blocks=new Map,t&&Symbol.iterator in t)for(const e of t){if(!Array.isArray(e)||2!==e.length)throw new Error("First parameter to HexMemoryMap constructor must be an iterable of [addr, bytes] or undefined");this.set(e[0],e[1])}else if("object"==typeof t){if(t){const e=Object.keys(t);for(const r of e)this.set(a(r),t[r])}}else if(null!=t)throw new Error("First parameter to HexMemoryMap constructor must be an iterable of [addr, bytes] or undefined")}set(t,e){if(!Number.isInteger(t))throw new Error("Address passed to HexMemoryMap is not an integer");if(t<0)throw new Error("Address passed to HexMemoryMap is negative");if(!(e instanceof Buffer))throw new Error("Bytes passed to HexMemoryMap are not an Buffer");return this._blocks.set(t,e)}get(t){return this._blocks.get(t)}clear(){return this._blocks.clear()}delete(t){return this._blocks.delete(t)}entries(){return this._blocks.entries()}forEach(t,e){return this._blocks.forEach(t,e)}has(t){return this._blocks.has(t)}keys(){return this._blocks.keys()}values(){return this._blocks.values()}get size(){return this._blocks.size}[Symbol.iterator](){return this._blocks[Symbol.iterator]()}static fromHex(t,e=1/0){const n=new i;let f,l=0,c=0,h=0;for(r.lastIndex=0;null!==(f=r.exec(t));){if(c++,l!==f.index)throw new Error("Malformed hex file: Could not parse between characters "+l+" and "+f.index+' ("'+t.substring(l,Math.min(f.index,l+16)).trim()+'")');l=r.lastIndex;const[,i,u]=f,g=Buffer.from(i.match(/[\da-f]{2}/gi)?.map(t=>a(t,16))||[]),d=g[0];if(d+4!==g.length)throw new Error("Mismatched record length at record "+c+" ("+f[0].trim()+"), expected "+d+" data bytes but actual length is "+(g.length-4));const p=o(g);if(a(u,16)!==p)throw new Error("Checksum failed at record "+c+" ("+f[0].trim()+"), should be "+p.toString(16));const b=(g[1]<<8)+g[2],w=g[3],m=g.subarray(4);if(0===w){if(n.has(h+b))throw new Error("Duplicated data at record "+c+" ("+f[0].trim()+")");if(b+m.length>65536)throw new Error("Data at record "+c+" ("+f[0].trim()+") wraps over 0xFFFF. This would trigger ambiguous behaviour. Please restructure your data so that for every record the data offset plus the data length do not exceed 0xFFFF.");n.set(h+b,m)}else{if(0!==b)throw new Error("Record "+c+" ("+f[0].trim()+") must have 0000 as data offset.");switch(w){case 1:if(l!==t.length)throw new Error("There is data after an EOF record at record "+c);return n.join(e);case 2:h=(m[0]<<8)+m[1]<<4>>>0;break;case 3:case 5:break;case 4:h=(m[0]<<8)+m[1]<<16>>>0;break;default:throw new Error("Invalid record type 0x"+s(w)+" at record "+c+" (should be between 0x00 and 0x05)")}}}throw c?new Error("No EOF record at end of file"):new Error("Malformed .hex file, could not parse any registers")}join(t=1/0){const e=Array.from(this.keys()).sort((t,e)=>t-e),r=new Map;let o=-1,n=-1;for(let s=0,a=e.length;s<a;s++){const a=e[s],i=this.get(e[s]).length;if(n===a&&n-o<t)r.set(o,r.get(o)+i),n+=i;else{if(!(n<=a))throw new Error("Overlapping data around address 0x"+a.toString(16));r.set(a,i),o=a,n=a+i}}const s=new i;let a,f=-1;for(let t=0,o=e.length;t<o;t++){const o=e[t];r.has(o)&&(a=Buffer.alloc(r.get(o)),s.set(o,a),f=o),a.set(this.get(o),o-f)}return s}static overlapHexMemoryMaps(t){const e=new Set;for(const[,r]of t)for(const[t,o]of r)e.add(t),e.add(t+o.length);const r=Array.from(e.values()).sort((t,e)=>t-e),o=new Map;for(let e=0,n=r.length-1;e<n;e++){const n=r[e],s=r[e+1],a=[];for(const[e,r]of t){const t=Array.from(r.keys()).reduce((t,e)=>e>n?t:Math.max(t,e),-1);if(-1!==t){const o=r.get(t),i=n-t,f=s-t;i<o.length&&a.push([e,o.subarray(i,f)])}}a.length&&o.set(n,a)}return o}static flattenOverlaps(t){return new i(Array.from(t.entries()).map(([t,e])=>[t,e[e.length-1][1]]))}paginate(t=1024,e=255){if(t<=0)throw new Error("Page size must be greater than zero");const r=new i;let o;const n=Array.from(this.keys()).sort((t,e)=>t-e);for(let s=0,a=n.length;s<a;s++){const a=n[s],i=this.get(a),f=i.length,l=a+f;for(let n=a-a%t;n<l;n+=t){o=r.get(n),o||(o=Buffer.alloc(t),o.fill(e),r.set(n,o));const s=n-a;let l;s<=0?(l=i.subarray(0,Math.min(t+s,f)),o.set(l,-s)):(l=i.subarray(s,s+Math.min(t,f-s)),o.set(l,0))}}return r}getUint32(t,e){const r=Array.from(this.keys());for(let o=0,n=r.length;o<n;o++){const n=r[o],s=this.get(n),a=s.length;if(n<=t&&t+4<=n+a)return new DataView(s.buffer,t-n,4).getUint32(0,e)}}asHexString(t=16){let e=0,r=-65536;const a=[];if(t<=0)throw new Error("Size of record must be greater than zero");if(t>255)throw new Error("Size of record must be less than 256");const i=Buffer.alloc(6),f=Buffer.alloc(4),l=Array.from(this.keys()).sort((t,e)=>t-e);for(let c=0,h=l.length;c<h;c++){const h=l[c],u=this.get(h);if(!(u instanceof Buffer))throw new Error("Block at offset "+h+" is not an Buffer");if(h<0)throw new Error("Block at offset "+h+" has a negative thus invalid address");const g=u.length;if(!g)continue;if(h>r+65535&&(r=h-h%65536,e=0,i[0]=2,i[1]=0,i[2]=0,i[3]=4,i[4]=r>>24,i[5]=r>>16,a.push(":"+Array.prototype.map.call(i,s).join("")+s(o(i)))),h<r+e)throw new Error("Block starting at 0x"+h.toString(16)+" overlaps with a previous block.");e=h%65536;let d=0;const p=h+g;if(p>4294967295)throw new Error("Data cannot be over 0xFFFFFFFF");for(;r+e<p;){e>65535&&(r+=65536,e=0,i[0]=2,i[1]=0,i[2]=0,i[3]=4,i[4]=r>>24,i[5]=r>>16,a.push(":"+Array.prototype.map.call(i,s).join("")+s(o(i))));let l=-1;for(;e<65536&&l;)if(l=Math.min(t,p-r-e,65536-e),l){f[0]=l,f[1]=e>>8,f[2]=e,f[3]=0;const t=u.subarray(d,d+l);a.push(":"+Array.prototype.map.call(f,s).join("")+Array.prototype.map.call(t,s).join("")+s(n(f,t))),d+=l,e+=l}}}return a.push(":00000001FF"),a.join("\n")}clone(){const t=new i;for(const[e,r]of this)t.set(e,Buffer.from(r));return t}static fromPaddedBuffer(t,e=255,r=64){if(!(t instanceof Buffer))throw new Error("Bytes passed to fromPaddedBuffer are not an Buffer");const o=new i;let n=0,s=-1,a=0,f=!1;const l=t.length;for(let i=0;i<l;i++)t[i]===e?(n++,n>=r&&(-1!==s&&o.set(a,t.subarray(a,s+1)),f=!0)):(f&&(f=!1,a=i),s=i,n=0);return f||-1===s||o.set(a,t.subarray(a,l)),o}slice(t,e=1/0){if(e<0)throw new Error("Length of the slice cannot be negative");const r=new i;for(const[o,n]of this){const s=n.length;if(o+s>=t&&o<t+e){const a=Math.max(t,o),i=Math.min(t+e,o+s)-a,f=a-o;i>0&&r.set(a,n.subarray(f,f+i))}}return r}slicePad(t,e,r=255){if(e<0)throw new Error("Length of the slice cannot be negative");const o=Buffer.alloc(e,r);for(const[r,n]of this){const s=n.length;if(r+s>=t&&r<t+e){const a=Math.max(t,r),i=Math.min(t+e,r+s)-a,f=a-r;i>0&&o.set(n.subarray(f,f+i),a-t)}}return o}contains(t){for(const[e,r]of t){const t=r.length,o=this.slice(e,t).join().get(e);if(!o||o.length!==t)return!1;for(const t in r)if(r[t]!==o[t])return!1}return!0}}class f{_blocks;constructor(t){if(this._blocks=new Map,t&&Symbol.iterator in t)for(const e of t){if(!Array.isArray(e)||2!==e.length)throw new Error("First parameter to S19MemoryMap constructor must be an iterable of [addr, bytes] or undefined");this.set(e[0],e[1])}else if("object"==typeof t){if(t){const e=Object.keys(t);for(const r of e)this.set(a(r),t[r])}}else if(null!=t)throw new Error("First parameter to S19MemoryMap constructor must be an iterable of [addr, bytes] or undefined")}set(t,e){if(!Number.isInteger(t))throw new Error("Address passed to S19MemoryMap is not an integer");if(t<0)throw new Error("Address passed to S19MemoryMap is negative");if(!(e instanceof Buffer))throw new Error("Bytes passed to S19MemoryMap are not an Buffer");return this._blocks.set(t,e)}get(t){return this._blocks.get(t)}clear(){return this._blocks.clear()}delete(t){return this._blocks.delete(t)}entries(){return this._blocks.entries()}forEach(t,e){return this._blocks.forEach(t,e)}has(t){return this._blocks.has(t)}keys(){return this._blocks.keys()}values(){return this._blocks.values()}get size(){return this._blocks.size}[Symbol.iterator](){return this._blocks[Symbol.iterator]()}static fromS19(t,e=1/0){const r=new f,o=t.split(/\r?\n/);let n=0,s=0;for(const t of o){const e=t.trim();if(!e)continue;if(n++,!e.startsWith("S"))throw new Error(`Line ${n} does not start with 'S': "${e}"`);if(e.length<4)throw new Error(`Line ${n} is too short: "${e}"`);const o=a(e[1]),i=e.substr(2,2),f=a(i,16);if(isNaN(f))throw new Error(`Invalid length field in line ${n}: "${i}"`);const l=4+2*f;if(e.length!==l)throw new Error(`Line ${n} has incorrect length. Expected ${l}, got ${e.length}: "${e}"`);const c=e.substr(4);let h=f;for(let t=0;t<c.length-2;t+=2)h+=a(c.substr(t,2),16);h=255&~h;const u=a(c.substr(c.length-2),16);if(h!==u)throw new Error(`Checksum mismatch in line ${n}. Expected ${h.toString(16).toUpperCase().padStart(2,"0")}, got ${u.toString(16).toUpperCase().padStart(2,"0")}`);switch(o){case 0:case 5:case 6:break;case 1:{const t=a(c.substr(0,4),16),e=c.substr(4,c.length-6);if(e.length%2!=0)throw new Error(`Invalid data bytes length in line ${n}: "${e}"`);const o=Buffer.from(e.match(/.{2}/g)?.map(t=>a(t,16))||[]);o.length>0&&r.set(t,o)}break;case 2:{const t=a(c.substr(0,6),16),e=c.substr(6,c.length-8);if(e.length%2!=0)throw new Error(`Invalid data bytes length in line ${n}: "${e}"`);const o=Buffer.from(e.match(/.{2}/g)?.map(t=>a(t,16))||[]);o.length>0&&r.set(t,o)}break;case 3:{const t=a(c.substr(0,8),16),e=c.substr(8,c.length-10);if(e.length%2!=0)throw new Error(`Invalid data bytes length in line ${n}: "${e}"`);const o=Buffer.from(e.match(/.{2}/g)?.map(t=>a(t,16))||[]);o.length>0&&r.set(t,o)}break;case 7:s=a(c.substr(0,8),16);break;case 8:s=a(c.substr(0,6),16);break;case 9:s=a(c.substr(0,4),16);break;default:throw new Error(`Unsupported record type S${o} in line ${n}`)}}return r.join(e)}join(t=1/0){const e=Array.from(this.keys()).sort((t,e)=>t-e),r=new Map;let o=-1,n=-1;for(let s=0,a=e.length;s<a;s++){const a=e[s],i=this.get(e[s]).length;if(n===a&&n-o<t)r.set(o,r.get(o)+i),n+=i;else{if(!(n<=a))throw new Error("Overlapping data around address 0x"+a.toString(16));r.set(a,i),o=a,n=a+i}}const s=new f;let a,i=-1;for(let t=0,o=e.length;t<o;t++){const o=e[t];r.has(o)&&(a=Buffer.alloc(r.get(o)),s.set(o,a),i=o),a.set(this.get(o),o-i)}return s}static overlapS19MemoryMaps(t){const e=new Set;for(const[,r]of t)for(const[t,o]of r)e.add(t),e.add(t+o.length);const r=Array.from(e.values()).sort((t,e)=>t-e),o=new Map;for(let e=0,n=r.length-1;e<n;e++){const n=r[e],s=r[e+1],a=[];for(const[e,r]of t){const t=Array.from(r.keys()).reduce((t,e)=>e>n?t:Math.max(t,e),-1);if(-1!==t){const o=r.get(t),i=n-t,f=s-t;i<o.length&&a.push([e,o.subarray(i,f)])}}a.length&&o.set(n,a)}return o}static flattenOverlaps(t){return new f(Array.from(t.entries()).map(([t,e])=>[t,e[e.length-1][1]]))}paginate(t=1024,e=255){if(t<=0)throw new Error("Page size must be greater than zero");const r=new f;let o;const n=Array.from(this.keys()).sort((t,e)=>t-e);for(let s=0,a=n.length;s<a;s++){const a=n[s],i=this.get(a),f=i.length,l=a+f;for(let n=a-a%t;n<l;n+=t){o=r.get(n),o||(o=Buffer.alloc(t),o.fill(e),r.set(n,o));const s=n-a;let l;s<=0?(l=i.subarray(0,Math.min(t+s,f)),o.set(l,-s)):(l=i.subarray(s,s+Math.min(t,f-s)),o.set(l,0))}}return r}getUint32(t,e){const r=Array.from(this.keys());for(let o=0,n=r.length;o<n;o++){const n=r[o],s=this.get(n),a=s.length;if(n<=t&&t+4<=n+a)return new DataView(s.buffer,t-n,4).getUint32(0,e)}}asS19String(t=16){if(t<=0)throw new Error("Size of record must be greater than zero");if(t>255)throw new Error("Size of record must be less than 256");const e=[],r=Buffer.from("ECB S19 export");let o="S0";o+=(2+r.length+1).toString(16).toUpperCase().padStart(2,"0"),o+="0000",o+=Array.from(r).map(t=>t.toString(16).toUpperCase().padStart(2,"0")).join("");let n=2+r.length+1+0+0;for(const t of r)n+=t;n=255&~n,o+=n.toString(16).toUpperCase().padStart(2,"0"),e.push(o);let s=0;const a=Array.from(this.keys()).sort((t,e)=>t-e),i=a.length>0?Math.max(...a.map(t=>t+(this.get(t)?.length||0))):0;let f="S1",l=2;i>16777215?(f="S3",l=4):i>65535&&(f="S2",l=3);for(const r of a){const o=this.get(r);if(!o||0===o.length)continue;let n=r;for(let r=0;r<o.length;r+=t){const a=Math.min(t,o.length-r),i=o.subarray(r,r+a);let c=f;const h=l+1+a;c+=h.toString(16).toUpperCase().padStart(2,"0"),c+=n.toString(16).toUpperCase().padStart(2*l,"0"),c+=Array.from(i).map(t=>t.toString(16).toUpperCase().padStart(2,"0")).join("");let u=h;"S3"===f?(u+=n>>24&255,u+=n>>16&255):"S2"===f&&(u+=n>>16&255),u+=n>>8&255,u+=255&n;for(const t of i)u+=t;u=255&~u,c+=u.toString(16).toUpperCase().padStart(2,"0"),e.push(c),n+=a,s++}}if(s<=65535){let t="S5";t+="03",t+=s.toString(16).toUpperCase().padStart(4,"0");let r=3+(s>>8&255)+(255&s);r=255&~r,t+=r.toString(16).toUpperCase().padStart(2,"0"),e.push(t)}let c="S3"===f?"S7":"S2"===f?"S8":"S9";const h=l,u=h+1;c+=u.toString(16).toUpperCase().padStart(2,"0"),c+="0000".padStart(2*h,"0");let g=u;for(let t=0;t<h;t++)g+=0;return g=255&~g,c+=g.toString(16).toUpperCase().padStart(2,"0"),e.push(c),e.join("\n")}clone(){const t=new f;for(const[e,r]of this)t.set(e,Buffer.from(r));return t}static fromPaddedBuffer(t,e=255,r=64){if(!(t instanceof Buffer))throw new Error("Bytes passed to fromPaddedBuffer are not an Buffer");const o=new f;let n=0,s=-1,a=0,i=!1;const l=t.length;for(let f=0;f<l;f++)t[f]===e?(n++,n>=r&&(-1!==s&&o.set(a,t.subarray(a,s+1)),i=!0)):(i&&(i=!1,a=f),s=f,n=0);return i||-1===s||o.set(a,t.subarray(a,l)),o}slice(t,e=1/0){if(e<0)throw new Error("Length of the slice cannot be negative");const r=new f;for(const[o,n]of this){const s=n.length;if(o+s>=t&&o<t+e){const a=Math.max(t,o),i=Math.min(t+e,o+s)-a,f=a-o;i>0&&r.set(a,n.subarray(f,f+i))}}return r}slicePad(t,e,r=255){if(e<0)throw new Error("Length of the slice cannot be negative");const o=Buffer.alloc(e,r);for(const[r,n]of this){const s=n.length;if(r+s>=t&&r<t+e){const a=Math.max(t,r),i=Math.min(t+e,r+s)-a,f=a-r;i>0&&o.set(n.subarray(f,f+i),a-t)}}return o}contains(t){for(const[e,r]of t){const t=r.length,o=this.slice(e,t).join().get(e);if(!o||o.length!==t)return!1;for(const t in r)if(r[t]!==o[t])return!1}return!0}}var l=exports;for(var c in e)l[c]=e[c];e.__esModule&&Object.defineProperty(l,"__esModule",{value:!0})})();
//# sourceMappingURL=utli.js.map